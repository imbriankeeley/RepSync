# RepSync Implementation Prompts — February 24, 2026

Each prompt below is self-contained. Copy-paste one at a time into a new Claude session to implement each feature. They should be done in order (Feature 7 must come before Feature 8 since they share a library dependency).

---

## Prompt 1: Anime GIFs on Home Screen

```
In MotivationalGif.kt (app/src/main/java/com/repsync/app/ui/components/MotivationalGif.kt), make the following changes:

1. Replace the 15 Giphy URLs in the `workoutGifs` list (lines 40-56) with 40 sexy but SFW anime girl GIF URLs (nothing NSFW/naked/sex — just attractive/lewd anime girls in SFW poses). Use direct media links from Giphy (format: https://media.giphy.com/media/XXXX/giphy.gif) or Tenor (format: https://media.tenor.com/XXXX/gif). Search for terms like "anime girl cute", "waifu", "anime workout", "anime flex", "anime girl motivation" etc.

2. Change the rotation logic from daily to every-app-open. Currently line 80-81:
   val dayOfYear = remember { LocalDate.now().dayOfYear }
   val gifUrl = remember { workoutGifs[dayOfYear % workoutGifs.size] }

   Change to a random selection that picks a new GIF each time the composable is first composed (app open):
   val gifUrl = remember { workoutGifs.random() }

   Remove the `dayOfYear` variable since it's no longer needed. Also update the fallback emoji selection to use .random() instead of dayOfYear-based index.

3. Optionally update the fallbackEmojis to anime-themed combos.

4. Keep ALL Coil loading logic (ImageLoader with GifDecoder/ImageDecoderDecoder, AsyncImage, error handling) completely unchanged.

No other files need to change.
```

---

## Prompt 2: Rest Timer — Foreground Service (Louder, Longer, Background)

```
Refactor the rest timer to use a foreground service so it works when the app is backgrounded, the phone screen is off, or music is playing. Make the alert louder (STREAM_ALARM) and double the duration (600ms → 1200ms).

## Step 1: Create RestTimerState singleton

Create app/src/main/java/com/repsync/app/service/RestTimerState.kt:

package com.repsync.app.service

import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow

object RestTimerState {
    val secondsRemaining = MutableStateFlow(0)
    val timerCompleted = MutableSharedFlow<Unit>(extraBufferCapacity = 1)
    val isRunning = MutableStateFlow(false)
}

## Step 2: Create RestTimerService foreground service

Create app/src/main/java/com/repsync/app/service/RestTimerService.kt:

- Extends Service()
- On startCommand: read EXTRA_DURATION_SECONDS from intent
- Create notification channel "rest_timer_channel" with IMPORTANCE_LOW (we don't want the notification itself to make noise — the service handles sound manually)
- Start foreground with persistent notification showing "Rest Timer: XX seconds remaining"
- Use CountDownTimer (android.os.CountDownTimer) for the countdown — NOT coroutines (more reliable in service context)
- Update notification and RestTimerState.secondsRemaining every tick
- On finish:
  - Play alarm sound via MediaPlayer using RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM) on AudioManager.STREAM_ALARM at max volume
  - Duration: 1200ms (use Handler.postDelayed to stop the MediaPlayer after 1200ms)
  - Vibrate with pattern: longArrayOf(0, 400, 200, 400, 200, 400, 200, 400) with VibrationEffect.createWaveform
  - Emit RestTimerState.timerCompleted
  - Set RestTimerState.isRunning = false
  - stopSelf()
- Handle ACTION_STOP: cancel timer, stop sound/vibration, update state, stopSelf()
- In onDestroy: clean up MediaPlayer, cancel timer

## Step 3: Update AndroidManifest.xml

Add these permissions (some may already exist):
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
<uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />

Register the service inside <application>:
<service
    android:name=".service.RestTimerService"
    android:foregroundServiceType="specialUse"
    android:exported="false" />

## Step 4: Update ActiveWorkoutManager.kt

Current timer logic is in lines 350-409 (startRestTimer, onRestTimerComplete, triggerVibration, triggerSound).

Replace:
- startRestTimer(): Instead of launching a coroutine Job, start RestTimerService:
  val intent = Intent(getApplication(), RestTimerService::class.java)
  intent.putExtra("EXTRA_DURATION_SECONDS", duration)
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      getApplication<Application>().startForegroundService(intent)
  } else {
      getApplication<Application>().startService(intent)
  }

- dismissRestTimer(): Send stop intent:
  val intent = Intent(getApplication(), RestTimerService::class.java)
  intent.action = "ACTION_STOP"
  getApplication<Application>().startService(intent)

- Remove: restTimerJob, the coroutine countdown loop, triggerVibration(), triggerSound()

- Add observation in init block:
  viewModelScope.launch {
      RestTimerState.secondsRemaining.collect { remaining ->
          val state = _activeWorkoutState.value ?: return@collect
          _activeWorkoutState.value = state.copy(restTimerSecondsRemaining = remaining)
      }
  }
  viewModelScope.launch {
      RestTimerState.timerCompleted.collect {
          onRestTimerComplete() // keep existing completion logic (minus sound/vibration which service handles)
      }
  }

- Simplify onRestTimerComplete() to just update UI state (reset timer display), since sound/vibration now handled by service.

## Step 5: ActiveWorkoutScreen.kt

The RestTimerBanner composable (around line 639) continues working since it reads restTimerSecondsRemaining from the same UI state. The "Skip" button calls viewModel.dismissRestTimer() which now sends ACTION_STOP to the service. No changes needed unless you want to add a notification action button for Skip.

## Testing:
- Start rest timer → press home → timer should continue → alarm should fire
- Start rest timer → play music → alarm should play over music (STREAM_ALARM)
- Start rest timer → lock phone → alarm should fire
- Tap Skip in-app → timer stops immediately
- Verify notification shows countdown
```

---

## Prompt 3: Calendar Day → DayView Set Details

```
The calendar day click already navigates to DayView (wired in RepSyncNavHost.kt). Enhance DayViewScreen to show expandable full set details instead of just the best set.

Currently in DayViewScreen.kt, the ExerciseSummaryRow composable only shows the best set (heaviest weight). The full set data is already loaded — CompletedExerciseWithSets has sets: List<CompletedSetEntity> with weight, reps, orderIndex.

## Changes:

1. In DayViewViewModel.kt (app/src/main/java/com/repsync/app/ui/viewmodel/DayViewViewModel.kt):
   - Add to DayViewUiState: expandedExerciseIds: Set<Long> = emptySet()
   - Add method:
     fun toggleExerciseExpanded(exerciseId: Long) {
         val current = _uiState.value.expandedExerciseIds
         _uiState.value = _uiState.value.copy(
             expandedExerciseIds = if (exerciseId in current) current - exerciseId else current + exerciseId
         )
     }

2. In DayViewScreen.kt (app/src/main/java/com/repsync/app/ui/screens/DayViewScreen.kt):
   - Pass expandedExerciseIds and toggleExerciseExpanded to CompletedWorkoutCard and ExerciseSummaryRow
   - Make the exercise row clickable (toggles expansion)
   - Add a small chevron icon (▼ when expanded, ▸ when collapsed) to the row
   - When expanded, show a Column below the summary row with each set:
     "Set 1: 135 × 10"
     "Set 2: 155 × 8"
     etc.
   - Sort sets by orderIndex
   - Use TextOnDarkSecondary color, slightly smaller font
   - Keep the existing exercise name click → ExerciseHistory navigation (maybe use the name text itself for history, and the row background for expand toggle)

Style the expanded sets to match the app's dark theme (BackgroundCard, TextOnDark, TextOnDarkSecondary).
```

---

## Prompt 4: Keyboard Scroll Behavior

```
Add keyboard-aware scrolling so content moves above the keyboard when text inputs are focused. Currently no screens use imePadding() or WindowInsets handling.

## Step 1: MainActivity.kt

In app/src/main/java/com/repsync/app/MainActivity.kt, add before setContent:

import androidx.core.view.WindowCompat

// In onCreate, before setContent:
WindowCompat.setDecorFitsSystemWindows(window, false)

## Step 2: Add imePadding() to Scaffold

In the Scaffold in MainActivity.kt, add .imePadding() to the modifier:

Scaffold(
    modifier = Modifier
        .fillMaxSize()
        .imePadding(),
    ...
)

Import: import androidx.compose.foundation.layout.imePadding

## Step 3: Test and adjust

If the Scaffold-level imePadding causes the bottom navigation bar to shift up with the keyboard (which looks odd since bottom nav isn't needed when typing), then instead:
- Remove imePadding from Scaffold
- Add .imePadding() to the root Column/Box of each screen that has text inputs:
  - ActiveWorkoutScreen.kt (weight/reps inputs in set rows)
  - NewWorkoutScreen.kt (workout name input, exercise name fields, weight/reps)
  - EditProfileScreen.kt (display name, reminder message inputs)
  - ProfileScreen.kt (AddBodyweightDialog weight input)

## Step 4: Optional — BringIntoViewRequester

For LazyColumn-based screens (ActiveWorkoutScreen, NewWorkoutScreen) where the focused input might still be partially hidden, add BringIntoViewRequester:

import androidx.compose.foundation.relocation.BringIntoViewRequester
import androidx.compose.foundation.relocation.bringIntoViewRequester

// On each text input field:
val bringIntoViewRequester = remember { BringIntoViewRequester() }
val coroutineScope = rememberCoroutineScope()

TextField(
    modifier = Modifier
        .bringIntoViewRequester(bringIntoViewRequester)
        .onFocusChanged {
            if (it.isFocused) {
                coroutineScope.launch { bringIntoViewRequester.bringIntoView() }
            }
        },
    ...
)

Only add this if imePadding alone doesn't scroll the focused field into view.
```

---

## Prompt 5: Move Streak Counter to Profile

```
Move the StreakBadge from HomeScreen to ProfileScreen.

## Step 1: Extract StreakBadge composable

The StreakBadge composable is currently private in HomeScreen.kt (lines 273-298). Extract it to a new file:

Create app/src/main/java/com/repsync/app/ui/components/StreakBadge.kt with the same composable but made public. It takes streak: Int as parameter and displays the fire emoji + "X Day Streak" in a rounded card.

## Step 2: Remove from HomeScreen

In HomeScreen.kt:
- Remove the StreakBadge call (around line 77, between CalendarCard and MotivationalGif)
- Remove the private StreakBadge composable definition (lines 273-298)
- Import the new public StreakBadge if needed elsewhere, but for now just remove it from Home

Optionally clean up HomeViewModel.kt:
- Remove currentStreak from HomeUiState if nothing else uses it
- Remove calculateStreak(), cachedWorkoutDates, cachedScheduledDays
- Keep workoutDates observation since the calendar still needs it for green dots

## Step 3: Add streak to ProfileViewModel

In ProfileViewModel.kt (app/src/main/java/com/repsync/app/ui/viewmodel/ProfileViewModel.kt):
- Add currentStreak: Int = 0 to ProfileUiState
- Copy the calculateStreak() method from HomeViewModel.kt (lines 79-131)
- Add observation of completedWorkoutDao.getDatesWithCompletedWorkouts() flow
- Calculate streak whenever workout dates or scheduled days change
- ProfileViewModel already has access to the database and workoutDaysPrefs

The streak calculation logic:
- No schedule: count consecutive days with workouts from today/yesterday backward
- With schedule: scheduled days require a workout to continue streak, rest days never break it but workouts on rest days count as bonus

## Step 4: Add to ProfileScreen

In ProfileScreen.kt, add between the profile card and bodyweight section (around line 135):

StreakBadge(streak = uiState.currentStreak)
Spacer(modifier = Modifier.height(12.dp))

Import the StreakBadge from ui.components.
```

---

## Prompt 6: Bodyweight Entries Separate Page

```
Convert the inline recent bodyweight entries list on ProfileScreen into a "View All Entries" button that navigates to a dedicated scrollable page with date range filtering, edit (weight only), and delete.

## Step 1: Add update query to BodyweightDao

In app/src/main/java/com/repsync/app/data/dao/BodyweightDao.kt, add:

@Query("UPDATE bodyweight_entries SET weight = :weight WHERE id = :id")
suspend fun updateWeight(id: Long, weight: Double)

No Room migration needed — this is just a new query on an existing table.

## Step 2: Add route to Screen.kt

In app/src/main/java/com/repsync/app/navigation/Screen.kt, add:

data object BodyweightEntries : Screen("bodyweight_entries")

## Step 3: Create BodyweightEntriesViewModel

Create app/src/main/java/com/repsync/app/ui/viewmodel/BodyweightEntriesViewModel.kt:

- UiState data class with:
  - entries: List<BodyweightEntryEntity> (all entries, reversed for newest-first display)
  - filteredEntries: List<BodyweightEntryEntity> (filtered subset, or same as entries if no filter)
  - startDate: LocalDate? = null
  - endDate: LocalDate? = null
  - editingEntry: BodyweightEntryEntity? = null
  - showEditDialog: Boolean = false
  - showDatePicker: Boolean = false

- Observe bodyweightDao.getAllEntriesChronological() flow, reverse for display
- When startDate/endDate are set, filter entries by parsing entry.date as LocalDate
- Methods: setDateRange(start, end), clearDateRange(), showEditDialog(entry), dismissEditDialog(), updateWeight(id, newWeight) via bodyweightDao.updateWeight(), deleteEntry(entry) via bodyweightDao.delete()

## Step 4: Create BodyweightEntriesScreen

Create app/src/main/java/com/repsync/app/ui/screens/BodyweightEntriesScreen.kt:

- Parameters: onNavigateBack: () -> Unit
- Top bar: back arrow button + "Bodyweight Entries" title (same style as DayViewScreen or ExerciseHistoryScreen headers)
- Date filter row: A button/chip showing "All Time" or "Jan 1 – Feb 24" when range is set. Tapping opens a date range picker dialog. Follow the same DateRangePickerDialog pattern used in ExerciseHistoryScreen.kt — look at that file for reference on how the date picker works in this app.
- "Clear" button to reset filter when active
- LazyColumn of filteredEntries:
  - Each row: date (formatted like "Feb 24, 2026"), weight ("185.5 lbs"), edit icon button (pencil), delete icon button (X in red/destructive color)
  - Match existing dark theme: BackgroundPrimary background, BackgroundCard for rows, TextOnDark for text
- Edit dialog: BasicTextField pre-filled with current weight, decimal keyboard, Save/Cancel buttons. On save: call viewModel.updateWeight(entry.id, newWeight)
- Delete: call viewModel.deleteEntry(entry) — maybe with a brief confirmation or just direct delete like current behavior
- Empty state: "No entries" or "No entries in selected range"

## Step 5: Wire navigation in RepSyncNavHost.kt

In app/src/main/java/com/repsync/app/navigation/RepSyncNavHost.kt, add:

composable(Screen.BodyweightEntries.route) {
    BodyweightEntriesScreen(
        onNavigateBack = { navController.popBackStack() }
    )
}

## Step 6: Update ProfileScreen

In ProfileScreen.kt:
- Add onNavigateToBodyweightEntries: () -> Unit parameter to ProfileScreen composable
- In BodyweightSection: remove the inline entries list (the "Recent Entries" text label and the scrollable Column of BodyweightEntryRow items — roughly lines 260-289)
- Replace with a "View All Entries" button styled as a pill/chip or TextButton in PrimaryGreen color
- Wire button to onNavigateToBodyweightEntries callback
- Keep the bodyweight chart and "+" add button on ProfileScreen as they are

In RepSyncNavHost.kt, update the ProfileScreen call to pass:
onNavigateToBodyweightEntries = { navController.navigate(Screen.BodyweightEntries.route) }
```

---

## Prompt 7: Drag to Reorder Workouts

```
Add drag-to-reorder for workouts in the workouts list screen using the sh.calvin.reorderable library. This requires adding an orderIndex column to WorkoutEntity with a Room migration.

## Step 1: Add dependency

In app/build.gradle.kts, add to dependencies:
implementation("sh.calvin.reorderable:reorderable:2.4.3")

Check Maven Central for the latest version at time of implementation. The library provides drag-and-drop reordering for Compose LazyColumn.

## Step 2: Add orderIndex to WorkoutEntity

In app/src/main/java/com/repsync/app/data/entity/WorkoutEntity.kt, add:
val orderIndex: Int = 0

Current fields are: id (Long, autoGenerate PK), name (String), createdAt (Long).

## Step 3: Room migration v2 → v3

In app/src/main/java/com/repsync/app/data/RepSyncDatabase.kt:

1. Bump version from 2 to 3 in @Database annotation
2. Add MIGRATION_2_3:

private val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(db: SupportSQLiteDatabase) {
        db.execSQL("ALTER TABLE workouts ADD COLUMN orderIndex INTEGER NOT NULL DEFAULT 0")
        // Initialize orderIndex to preserve current createdAt DESC ordering
        // (most recent gets lowest index = appears first, matching current behavior)
        db.execSQL("""
            UPDATE workouts SET orderIndex = (
                SELECT COUNT(*) FROM workouts w2 WHERE w2.createdAt > workouts.createdAt
            )
        """)
    }
}

3. Add to builder: .addMigrations(MIGRATION_1_2, MIGRATION_2_3)

## Step 4: Update WorkoutDao

In app/src/main/java/com/repsync/app/data/dao/WorkoutDao.kt:

1. Change ALL queries with "ORDER BY createdAt DESC" to "ORDER BY orderIndex ASC":
   - getAllWorkouts()
   - getAllWorkoutsWithExercises()
   - searchWorkouts()

2. Add new queries:
   @Query("UPDATE workouts SET orderIndex = :orderIndex WHERE id = :id")
   suspend fun updateWorkoutOrder(id: Long, orderIndex: Int)

   @Query("SELECT COUNT(*) FROM workouts")
   suspend fun getWorkoutCount(): Int

## Step 5: Update WorkoutsListViewModel

In app/src/main/java/com/repsync/app/ui/viewmodel/WorkoutsListViewModel.kt:

Add methods:
fun moveWorkout(fromIndex: Int, toIndex: Int) {
    val currentWorkouts = _uiState.value.workouts.toMutableList()
    val item = currentWorkouts.removeAt(fromIndex)
    currentWorkouts.add(toIndex, item)
    _uiState.value = _uiState.value.copy(workouts = currentWorkouts)
}

fun saveWorkoutOrder() {
    viewModelScope.launch {
        _uiState.value.workouts.forEachIndexed { index, workoutWithExercises ->
            workoutDao.updateWorkoutOrder(workoutWithExercises.workout.id, index)
        }
    }
}

## Step 6: Update WorkoutsListScreen

In app/src/main/java/com/repsync/app/ui/screens/WorkoutsListScreen.kt:

Replace the LazyColumn with the reorderable version from sh.calvin.reorderable. The exact API depends on the library version — check the README. General pattern:

- Use rememberReorderableLazyListState or similar
- Wrap each workout item in ReorderableItem
- Long-press initiates drag
- On move: call viewModel.moveWorkout(from.index, to.index)
- On drag end: call viewModel.saveWorkoutOrder()
- Add visual feedback when dragging (slightly elevated, semi-transparent background)
- IMPORTANT: Only enable reorder when search is NOT active. When searchQuery is not blank, show a regular non-reorderable LazyColumn to avoid index confusion between filtered and full lists.

## Step 7: New workout ordering

In NewWorkoutViewModel.kt, when saving a new workout, set orderIndex to append at bottom:
val count = workoutDao.getWorkoutCount()
val workoutId = workoutDao.insertWorkout(WorkoutEntity(name = state.workoutName, orderIndex = count))

## Testing:
- Long-press a workout → drag up/down → release → order persists
- Close app → reopen → order preserved
- Create new workout → appears at bottom of list
- Search mode → normal list (no drag)
- Verify existing data preserves current order after migration
```

---

## Prompt 8: Drag to Reorder Exercises

```
Add drag-to-reorder for exercises within workouts on the New Workout / Edit Workout screen. Uses the sh.calvin.reorderable library (already added in the workouts reorder feature).

ExerciseEntity already has an orderIndex field, so no Room migration is needed. The orderIndex is assigned from list position during saveWorkout() via forEachIndexed.

## Step 1: Add moveExercise to NewWorkoutViewModel

In app/src/main/java/com/repsync/app/ui/viewmodel/NewWorkoutViewModel.kt, add:

fun moveExercise(fromIndex: Int, toIndex: Int) {
    val currentExercises = _uiState.value.exercises.toMutableList()
    val item = currentExercises.removeAt(fromIndex)
    currentExercises.add(toIndex, item)
    _uiState.value = _uiState.value.copy(exercises = currentExercises)
}

No separate "save order" needed — saveWorkout() already assigns orderIndex from list position.

## Step 2: Update NewWorkoutScreen with reorderable exercises

In app/src/main/java/com/repsync/app/ui/screens/NewWorkoutScreen.kt:

The exercise cards are rendered in a LazyColumn with itemsIndexed. Replace the exercise items section with the reorderable version:

- Import the sh.calvin.reorderable library (already in dependencies)
- Use the reorderable state and ReorderableItem for exercise cards
- Each exercise card should have a drag handle icon (three horizontal lines / grip dots) for discoverability
- Long-press on the drag handle (or anywhere on the card) to initiate drag
- On move: call viewModel.moveExercise(from.index, to.index)
- Exercise items use exercise.id (UUID string) as stable keys — these already exist

IMPORTANT: The LazyColumn has non-reorderable items too (workout name input at top, "Add Exercise" button at bottom). Only exercise cards should be ReorderableItem. The library should handle mixed item types if you correctly scope which items are reorderable vs regular.

Add visual feedback: slight elevation/scale change when an exercise is being dragged.

## Step 3 (Optional): Add to ActiveWorkoutScreen

In ActiveWorkoutManager.kt, add:
fun moveExercise(fromIndex: Int, toIndex: Int) {
    val current = _activeWorkoutState.value ?: return
    val exercises = current.exercises.toMutableList()
    val item = exercises.removeAt(fromIndex)
    exercises.add(toIndex, item)
    _activeWorkoutState.value = current.copy(exercises = exercises)
}

In ActiveWorkoutScreen.kt, add the same reorderable pattern for exercise cards. This is lower priority — users typically set exercise order when creating/editing templates, not during active workouts.

## Step 4: Drag handle composable

Add a small drag handle to each exercise card. Can be a simple icon:

Icon(
    painter = painterResource(R.drawable.ic_drag_handle), // or use a simple "≡" text
    contentDescription = "Drag to reorder",
    tint = TextOnDarkSecondary,
    modifier = Modifier.size(24.dp)
)

Or use the Unicode character "⠿" (braille dots) or "≡" as a text-based handle if you don't want to add a drawable resource.

Place the handle at the start (left side) of each exercise card header row.
```

---

## Notes

- **Implementation order matters:** Feature 7 adds the reorderable library dependency, so do it before Feature 8.
- **Feature 2 is the most complex** — test thoroughly on a physical device with background/lock scenarios.
- **Feature 3 may already work** — verify the calendar → DayView navigation first before adding expansion.
- **Build after each feature:** Run `./gradlew assembleDebug` to catch compilation errors early.
- **DB migration (Feature 7):** Test on a device with existing data to verify the migration preserves workout order.
